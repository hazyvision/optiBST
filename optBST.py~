
#Written by Adriene Cuenco

#!/usr/bin/python

#Optimal Binary Search Tree
#Input: A list of probabilities with a corresponding list of keys
#Output: The list of probabilities, minimum average of search time, 
#        and the optimal binary search tree

def findMin(a,i,j):
	indexLow  = 1
	sumLow =  a[i][0] + a[2][j]
	for k in range(i,j+1):
		test = a[i][k-1] + a[k+1][j]
		if sumLow > test: 
			sumLow = test
			indexLow=int(k)
	return indexLow

def memory(a,i,j):
	if a[i][j] is None: 
		result = a[i][int(k)-1] + a[int(k)+1][j] + sumProb(a,i,j) 
		a[i][j] = result
	else:   
		result = a[i][j]
	return result

def sumProb(a, i, j):
	sum = 0
	j+=1
	for x in range(i,j+1):
		sum+=(prob[x])
	return sum 


def optBST(n , p, r):
	 a = [[None for x in range(n+1)] for y in range(n+2)]
	 for i in range(1,n+1):
	 	a[i][i-1] = 0
	 	a[i][i] = p[i]
	 	r[i][i] = i
	 	r[i][i-1] = 0

	 a[n+1][n] = 0
	 r[n+1][n] = 0

	 for diagonal in range(1,n-1):
	 	for i in range(1, n-diagonal):
	 		j = i + diagonal
	 		k = findMin(a,i,j)
	 		memory(a, i , j)
	 		r[i][j] = k
	 minavg = a
	 print(minavg)
	 #Extra prints for debug. Delete before submission.
	 print("r = ") 
	 print(r)
	 print("n = ")
	 print(n)
	 return;

prob = [None, 3/8, 3/8, 1/8, 1/8 ]
keys = [None, "Don", "Isabelle", "Ralph", "Wally"]
k=0
n = len(keys) - 1 
r = [[None for x in range(n+1)] for y in range(n+2)] 
optBST(n, prob, r)
